#!/bin/bash
#
# funccost - count kernel function costs matching specified wildcards.
#             Uses Linux ftrace.
#
# This is a proof of concept using Linux ftrace capabilities on older kernels,
# and works by using function profiling: in-kernel counters.
#
# USAGE: funccost [-hT] [-i secs] [-d secs] [-t top] funcstring
#    eg,
#        funccost 'ext3*'	# count all ext3* kernel function costs
#
# Run "funccost -h" for full usage.
#
# WARNING: This uses dynamic tracing of kernel functions, and could cause
# kernel panics or freezes. Test, and know what you are doing, before use.
#
# REQUIREMENTS: CONFIG_FUNCTION_PROFILER, awk.
#
# From perf-tools: https://github.com/brendangregg/perf-tools
#
# COPYRIGHT: Copyright (c) 2014 Brendan Gregg.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)
#
# 12-Jul-2014	Brendan Gregg	Created this.

### default variables
tracing=/sys/kernel/debug/tracing
opt_duration=0; duration=; opt_interval=0; interval=999999; opt_timestamp=0; opt_lustre_mods=0;
opt_tail=0; tcmd=cat; opt_sort_avg=0; ttext=
trace_target=""
trap 'quit=1' INT QUIT TERM PIPE HUP	# sends execution to end tracing section

function usage {
	cat <<-END >&2
	USAGE: funccost [-hsTL] [-i secs] [-d secs] [-t top] funcstring
	                 -d seconds      # total duration of trace
	                 -h              # this usage message
	                 -i seconds      # interval summary
	                 -t top          # show top num entries only
	                 -T              # include timestamp (for -i)
	                 -L		 # profiling lustre related modules
	                 -s		 # sort by avg time cost
	  eg,
	       funccost 'vfs*'          	# trace all funcs that match "vfs*"
	       funccost 'vfs_stat,vfs_getattr'  # trace multiple funcs, split by ','
	       funccost -d 5 'tcp*'     	# trace "tcp*" funcs for 5 seconds
	       funccost -t 10 'ext3*'   	# show top 10 "ext3*" funcs
	       funccost -i 1 'ext3*'    	# summary every 1 second
	       funccost -i 1 -d 5 'ext3*' 	# 5 x 1 second summaries

	See the man page and example file for more info.
END
	exit
}

function warn {
	if ! eval "$@"; then
		echo >&2 "WARNING: command failed \"$@\""
	fi
}

function die {
	echo >&2 "$@"
	exit 1
}

### process options
while getopts d:hi:t:TLs opt
do
	case $opt in
	d)	opt_duration=1; duration=$OPTARG ;;
	i)	opt_interval=1; interval=$OPTARG ;;
	t)	opt_tail=1; tnum=$OPTARG ;;
	T)	opt_timestamp=1 ;;
	L)	opt_lustre_mods=1 ;;
	s)	opt_sort_avg=1 ;;
	h|?)	usage ;;
	esac
done
shift $(( $OPTIND - 1 ))

### option logic
if ((!opt_lustre_mods)); then
	(( $# != 0 )) && funcs="$1"
fi
if (( opt_tail )); then
	tcmd="head -$tnum"
	ttext=" Top $tnum only."

fi

(( opt_duration && !opt_interval )) && interval=$duration

### check permissions
cd $tracing || die "ERROR: accessing tracing. Root user? Kernel has FTRACE?
    debugfs mounted? (mount -t debugfs debugfs /sys/kernel/debug)"

### enable tracing
sysctl -q kernel.ftrace_enabled=1	# doesn't set exit status

if ((opt_lustre_mods)); then
	echo "Start setting lustre functions..."
	echo > set_ftrace_filter
	MODS=$(ls -R /lib/modules/`uname -r`/extra/ | grep '.ko$' | awk -F '.' '{print $1}')
	for MOD in $MODS;
	do
		lsmod | grep -w $MOD >/dev/null 2>&1
		if [ $? -eq 0 ]; then
			echo ":mod:$MOD" >> set_ftrace_filter || die "ERROR: enabling \"$funcs\". Exiting."
		fi
	done
	echo "Setting lustre functions done..."
else
	echo > set_ftrace_filter
	func_arr=($(echo $funcs|tr ',' ' '|tr -s ' '))
	for subfunc in ${func_arr[@]}; do
		echo "$subfunc" >> set_ftrace_filter || die "ERROR: enabling \"$funcs\". Exiting."
	done
fi

if ((opt_lustre_mods)); then
       trace_target="[lustre modules functions]"
else
       trace_target=$funcs
fi

if (( opt_duration )); then
       echo "Tracing \"$trace_target\" for $duration seconds.$ttext.."
else
       echo "Tracing \"$trace_target\".$ttext.. Ctrl-C to end."
fi

warn "echo nop > current_tracer"
if ! echo 1 > function_profile_enabled; then
	echo > set_ftrace_filter
	die "ERROR: enabling function profiling."\
	    "Have CONFIG_FUNCTION_PROFILER? Exiting."
fi

### always unpause tracing
echo 1 > tracing_enabled
### summarize
quit=0; secs=0
while (( !quit && (!opt_duration || secs < duration) )); do
	(( secs += interval ))
	echo 0 > function_profile_enabled
	echo 1 > function_profile_enabled
	sleep $interval

	echo
	(( opt_timestamp )) && date
	if ((opt_sort_avg)); then
		printf "%-30s %-12s %-12s %-20s\n" "FUNC" "AVG(us)" "COUNT" "TOTAL_TIME(us)"
		cat trace_stat/function* | awk '
		# skip headers by matching on the numeric hit column
		$2 ~ /[0-9]/ { a[$1] += $3;b[$1] += $2;c[$1] += $5}
		END {
			for (k in a) {
				printf "%-30s %-12.2f %-12d %-20d\n", k,  a[k]/b[k],  b[k],  a[k]
			}
		}' | sort -nr -k2 | $tcmd
		
	else
		printf "%-30s %-20s %-12s %-14s\n" "FUNC"  "TOTAL_TIME(us)" "COUNT" "AVG(us)"
		cat trace_stat/function* | awk '
		# skip headers by matching on the numeric hit column
		$2 ~ /[0-9]/ { a[$1] += $3;b[$1] += $2;c[$1] += $5}
		END {
			for (k in a) {
				printf "%-30s %-20d %-12d %-12.2f\n", k,  a[k],  b[k],  a[k]/b[k]
			}
		}' | sort -nr -k2 | $tcmd
	fi
done

### end tracing
echo 2>/dev/null
echo "Ending tracing..." 2>/dev/null
warn "echo 0 > function_profile_enabled"
warn "echo > set_ftrace_filter"
